import bisect
"""
스위치와 전구의 번호를 매핑하기 위해 딕셔너리 d를 사용합니다.
d의 키는 스위치 번호이며, 값은 해당 스위치의 인덱스(전구 번호와 매칭됨)입니다.
q 는 현재까지 선택한 스위치번호
c 는 스위치 번호로 많은 전구를 켜는 데 필요한 최적의 스위치 수
e 는 켜는 스위치 번호로 많은 전구를 켜는 데 필요한 최적의 스위치 수
"""
d,q,c,e={},[],[],[]
n=int(input())
"""
스위치와 전구의 번호를 입력받고, 딕셔너리 d를 초기화합니다.
"""
for i in map(int,input().split()):
    d[i]=0
"""
스위치 번호를 입력받을 때마다 d 딕셔너리를 업데이트하여 스위치와 전구를 매핑합니다.
"""
for k,i in enumerate(map(int,input().split())):
    d[i]=k
"""
빈 리스트 q는 현재까지 선택한 스위치 번호를 저장합니다.
빈 리스트 c는 현재까지 선택한 스위치 번호로 가장 많은 전구를 켜는 데 필요한 최적의 스위치 수를 저장합니다.
스위치를 선택할 때마다 bisect_left 함수를 사용하여 q 리스트 내에서 스위치를 정렬된 순서로 삽입합니다. 
이때, c 리스트에는 해당 스위치가 몇 번째 스위치인지를 저장합니다.
"""
for k,i in d.items():
    s=bisect.bisect_left(q,i)
    if s!=len(q):q[s]=i
    else:q+=[i]
    c+=[s]
s=len(q)
print(s)
"""
마지막으로, c 리스트를 역순으로 순회하면서 가장 많은 전구를 켜는 데 필요한 스위치를 선택합니다. 
이때, 스위치의 번호는 d 딕셔너리의 키값으로 다시 변환하여 출력합니다.
"""
for i in range(n-1,-1,-1):
    if c[i]==s-1:e+=[list(d)[i]];s-=1
print(' '.join(map(str,sorted(e))))

"""
이 코드의 시간 복잡도는 O(Nlog(N))입니다.
이는 스위치 번호와 전구 번호를 매핑하는 초기 반복문과 
bisect_left 함수를 호출하는 반복문의 시간 복잡도가 각각 O(Nlog(N))이기 때문입니다.
코드는 주어진 문제를 효과적으로 해결하고 가장 많은 전구를 켤 수 있는 스위치 번호를 찾아냅니다.
"""